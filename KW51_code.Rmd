---
title: "Estimation of the Conditional Mean, Covariance and Correlation of the Frequency Data from Railway Bridge KW51"
author: "Lizzie Neumann"
date: "2024-01-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This code provides the estimation of the conditional covariance as presented 
in "Confounder-adjusted Covariances of Sensor Outputs and Applications to 
Structural Health Monitoring" by L. Neumann, P. Wittenberg, A. Mendler, and 
J. Gertheiss [3]

TODO: indicates you can choose or change a variable or method to compare, e.g.,
different bandwidths or methods for estimating the conditional
mean. 

This code contains estimation of the Nadaraya-Watson
type kernel estimation of the conditional mean and covariance
and different estimations of the conditional mean (bilinear, gam, loess, kernel)
of the modal data of the railway bridge KW51.


Contact for questions: Lizzie Neumann, neumannl(at)hsu-hh.de

```{r libraries, message=FALSE, warning=FALSE, include=FALSE}
## load libraries
suppressPackageStartupMessages({
  library(covest) # our package, in functions folder
  library(tidyr)
  library(dplyr)
  library(patchwork)
  library(zoo)
  library(pracma)
  library(segmented)
  library(ggplot2)
  library(mgcv)
  library(stats)
  library(R.matlab)
  library(viridis)
})
```

# Inread Data (TODO: Windows or Linux?)

The data set is available from https://zenodo.org/records/3745914, cf. [1], and 
for information on the bridge compare [2]. The time is separated in three periods,
before, during, and after retrofitting. In this section we load the data from 
the website. There are different versions for Windows and Linux.
```{r inreadData}
## TODO: Windows or Linux? Comment out what is not required 

## WINDOWS ##

## download data file
url <- "https://zenodo.org/records/3745914/files/trackedmodes.zip?download=1"
path1 <- tempfile(fileext = ".zip")
if (file.exists(path1))  'file alredy exists' else download.file(url, path1, mode="wb")
unzip(zipfile = path1,exdir = tempdir())

list.import.mat <- R.matlab::readMat(paste0(tempdir(),"/trackedmodes/trackedmodes.mat")) 

## -------------------------------------------------------------------------- ##
## LINUX ##

## download data file
# download.file("https://zenodo.org/records/3745914/files/trackedmodes.zip?download=1", 
#               "trackedmodes.zip", method ="auto")

## unzip data file
# unzip("trackedmodes.zip")

## inread data
# list.import.mat <- R.matlab::readMat("trackedmodes/trackedmodes.mat")

```


# Extracting the temperature and modal data

In this step, we extract the steel surface temperature data and the modal data 
from the downloaded data set. The time stamp is changed to POSIXt format. We use
only the data from before the retrofitting, Oct 2nd, 2018 - May 14th, 2019.

```{r data}
## temperature data
df1 <- list.import.mat$modes[7][[1]] |>
  data.frame() |>
  `colnames<-`(list.import.mat$modes[6][[1]] |> unlist()) |>
  mutate(time=c(list.import.mat$modes[1][[1]])) |>
  mutate(time=as.Date(time, tz="UTC", origin="0000-01-01")) |>
  mutate(time=seq(
    as.POSIXlt(paste0(first(time), " 0:00:00"), tz="UTC"),
    as.POSIXlt(paste0(last(time), " 23:00:00"), tz="UTC"), by = "hour")) |>
  group_by(format(time, "%Y-%m-%d")) |>
  mutate(ind_day=cur_group_id()) |>
  ungroup() |>
  rename(date=time)

## tracked modes
df2 <- list.import.mat$modes[2][[1]] |>
  data.frame() |>
  `colnames<-`(paste0("ef", 1:14)) |>
  mutate(time=c(list.import.mat$modes[1][[1]])) |>
  mutate(time=as.Date(time, tz="UTC", origin="0000-01-01")) |>
  mutate(time=seq(
    as.POSIXlt(paste0(first(time), " 0:00:00"), tz="UTC"),
    as.POSIXlt(paste0(last(time), " 23:00:00"), tz="UTC"), by = "hour")) 

## combine the data frames
data_ef_t <- cbind(df2[,1:14], df1$tBD31A, df2$time)

colnames(data_ef_t) <- c(colnames(data_ef_t[,1:14]), "tBD31A", "time")

## only data before retrofitting : Oct 2nd, 2018 - May 14th, 2019
data_ef_t <- data_ef_t[1:5400,]

```


# Interpolate the Data

Due to some missing data, we choose only modes 3, 5, 6, 9, 10, 12, 13 and 14, 
and interpolate the missing data linearly as done in [2].

```{r interpolateData}
## choose mode 3, 5, 6, 9, 10, 12, 13 and 14 and the temperature
qq <- c(3,5,6,9,10,12,13,14,15)

## first 38 are NaN
df <- as.data.frame(data_ef_t[38:nrow(data_ef_t),qq]) 

## linear interpolate missing data 
data_ef_t <- df %>%
  mutate(ef3 = na.approx(ef3)) %>%
  mutate(ef5 = na.approx(ef5)) %>%
  mutate(ef6 = na.approx(ef6)) %>%
  mutate(ef9 = na.approx(ef9)) %>%
  mutate(ef10 = na.approx(ef10)) %>%
  mutate(ef12 = na.approx(ef12)) %>%
  mutate(ef13 = na.approx(ef13)) %>%
  mutate(ef14 = na.approx(ef14)) 

## number of modes
pp <- ncol(data_ef_t)-1

```


# Temperature Grid for Analysis

Estimation of the temperature grid: from minimum to maximum measured temperature
in steps of 0.1. The range is from -3°C to 26.3°C.

```{r temperatureGrid}
zseq <- seq(round(min(na.omit(data_ef_t$tBD31A)),1), 
            round(max(na.omit(data_ef_t$tBD31A)),1), by=.1)

c("min:", min(zseq), "max:", max(zseq))
```


# Different Approaches for the Estimation of the Conditional Mean

For estimating the conditional covariance we need a conditional estimation of the 
mean, here we implemented 4 different versions on how to estimate it. Cf. Section 
2.3 in [3]:

1. A bilinear model using R package segmented [SOURCE], cf. [2] and [3]. 

2. Penalized regression splines using mgcv [SOURCE], cf. Section 2.2 in [3]. 

3. Local Polynomial Regression using loess [SOURCE], cf. [3].

4. Nadaraya-Watson kernel estimator using our PACKAGE covest, cf. [3] and [4]. 
TODO: For this estimation we need bandwidths per mode, you can try different ones.

```{r conditionalMean}
## 1. estimate bilinear mean via segmented
mest_bl <- matrix(NA, ncol = pp, nrow = length(zseq))
for(p in 1:pp){
  ef_t <- na.omit(data.frame(x = data_ef_t[,p],z = data_ef_t[,ncol(data_ef_t)]))
  xz <- segmented::segmented(lm(x~z, data=ef_t))
  mest_bl[,p] <- predict(xz,data.frame(z = zseq))
}

## 2. estimate conditional mean via mgcv
mest_mgcv <- matrix(NA, ncol = pp, nrow = length(zseq))
for(p in 1:pp){
  ef_t <- na.omit(data.frame(x = data_ef_t[,p],z = data_ef_t[,ncol(data_ef_t)]))
  xz <- gam (x ~ s(z, bs="ps", k = 5), data = ef_t)
  mest_mgcv[,p] <- predict(xz,data.frame(z = zseq))
}

## 3. estimate conditional mean via loess
mest_loess <- matrix(NA, ncol = pp, nrow = length(zseq))
for(p in 1:pp){
  ef_t <- na.omit(data.frame(x = data_ef_t[,p],z = data_ef_t[,ncol(data_ef_t)]))
  xz <- loess(x ~ z, span = 0.75, data = ef_t)
  mest_loess[,p] <- predict(xz,data.frame(z = zseq))
}

## 4. estimate conditional Nadaraya-Watson-kernel-based mean via covest
# TODO: choose bandwidths
h_m <- c(1,1,1,1,1,1,1,1)
mest_nwk<- matrix(NA, ncol = pp, nrow = length(zseq))
for(p in 1:pp){
  for(k in 1:length(zseq)){
    ef_t <- na.omit(data.frame(x = data_ef_t[,p],
                               z = data_ef_t[,ncol(data_ef_t)]))
    mestk <- covest::meanest(x = as.matrix(ef_t$x), z = as.matrix(ef_t$z), 
                             znew = zseq[k], h = h_m[p], mean_old = 0, 
                             sumK_old = 0)
    mest_nwk[k,p] <- t(mestk[,1])
  }
}
```

# TODO: choose estmation of mean

```{r chooseMean}
# possible from: mest_bl, mest_mgcv, mest_loess, mest_nwk
mest <- mest_bl

```

# TODO: choose bandwidth h_c

For the estimation of the conditional covariance, we need bandwidths, either a 
global bandwidth for all mode pairs, or a different one for each mode pair. In
each column and row, we have the order mode: 3, 5, 6, 9, 10, 12, 13 and 14.

```{r choosehc}
## global:
# h_c <- matrix(2.5, nrow = pp, ncol = pp)
## pairwise:
h_c <- rbind(c(2.5,2.5,2.5,2.5,2.5,2.5,2.5,2.5),
             c(NA,2.5,2.5,2.5,2.5,2.5,2.5,2.5),
             c(rep(NA,2),2.5,2.5,2.5,2.5,2.5,2.5),
             c(rep(NA,3),2.5,2.5,2.5,2.5,2.5),
             c(rep(NA,4),2.5,2.5,2.5,2.5),
             c(rep(NA,5),2.5,2.5,2.5),
             c(rep(NA,6),2.5,2.5),
             c(rep(NA,7),2.5))
```


# Estimation of the Conditional Covariance and Correlation

Now we get to the estimation of the conditional covariance and correlation. 
It is done pairwise, so different bandwidths are taken into account. There is 
some missing data in the temperature measurements, so first of all we need to get 
rid of that. The conditional mean is then assigned to each time step, depending 
on the measured temperature. Afterwards, we can estimated the conditional covariance
according to Equation (6) in [3] (cf. Equation (2.3) in [4] and (4) in [3] for the
non pairwise estimation of the conditional covariance).

```{r conditionalCovariance}

## estimate conditional covariance for each sensor pair ii,jj = 1:2
cest  <- array(rep(NA, pp*(pp)*length(zseq)),
               dim=c(pp, pp, length(zseq)))

for(ii in 1:pp){
  for(jj in ii:pp){
    # cat(paste("ii = ",ii, "jj = ", jj), "\n")
    
    ## subset of data, removing NAs
    ef_t <- data_ef_t[,c(ii,jj,ncol(data_ef_t))]
    ef_t <- na.omit(ef_t)
    p <- ncol(ef_t)-1
    
    x <- ef_t[,1:2] # modal data
    z <- ef_t[,3] # temperature data
    
    ## assigning the conditional mean for the respective temperature at time i
    mx <- matrix(NA, nrow = nrow(x), ncol = p)
    z_x <- as.data.frame(cbind(round(zseq,1), 1:length(zseq)))
    for(i in 1:length(z)){
      x_i <- z_x[z_x[,1]==round(z[i],1),2]
      x_i <- x_i[1]
      mx[i,] <- mest[x_i,c(ii,jj)]
    }
    
    ## etimating the conditional covariance with the Nadaraya-Watson 
    ## kernel-based estimator for each temperature in the grid
    for (k in 1:length(zseq)){
      cest_old <- matrix(0,p,p)
      sumK_old <- 0
      cestk <- covest::covest(x = as.matrix(x), z = as.matrix(z), znew = zseq[k],
                              h = h_c[ii,jj], cest_old = matrix(0,p,p), 
                              sumK_old = 0, mx=mx)
      
      cest[ii,jj,k] <- cestk[1,2]
      cest[jj,ii,k] <- cestk[2,1]
    }
  }
}

## estimating the conditional correlation
corr <- array(rep(NA, pp*(pp)*length(zseq)),
              dim=c(pp, pp, length(zseq)))

for(k in 1:length(zseq)) corr[,,k] <- cov2cor(cest[,,k])

```

# Plot the lower triangular of the Conditional Correlation Matrix for Temperature Values z = -1°C and z = 10°C

Now the lower triangular of the conditional correlation is plotted without the 
main diagonal because the correlation between the same modes is always 1.

```{r plotCorrelation}
## plotting the conditional correlation of lower triangular 
## set theme & background
theme_set(theme_bw() +
            theme(panel.grid.major=element_blank(), 
                  panel.grid.minor=element_blank(),              
                  strip.background=element_rect(fill="white"),
                  strip.text=element_text(size=10, face="bold"),
                  plot.title=element_text(hjust=.5),
                  axis.text.x=element_text(color="black"),
                  axis.text.y=element_text(color="black"),
                  axis.ticks=element_line(color = "black")
            )
)


## lower triangular fo correlation matrix
corr_tri <- array(rep(NA, pp*pp*length(zseq)), dim = c(pp, pp, length(zseq)))
for(k in 1:length(zseq)){
   corr_k <- corr[,,k]
   corr_k[upper.tri(corr[,,k], diag = TRUE)] <- NA
   corr_tri[,,k] <- corr_k
}

df_p1 <- data.frame(y = c(rep(qq[2:pp], (pp-1)),rep(qq[2:8], (pp-1))), 
                    x = c(rep(qq[1:(pp-1)], each = (pp-1)),
                          rep(qq[1:(pp-1)], each = (pp-1))), 
                    z = c(as.vector(corr_tri[2:pp,1:(pp-1),21]), 
                          as.vector(corr_tri[2:pp,1:(pp-1),131])),
                    temp = c(rep("z = -1°C", (pp-1)*(pp-1)),
                             rep("z = 10°C", (pp-1)*(pp-1))))

df_p1 <- na.omit(df_p1)

p1 <- ggplot(df_p1, aes(x = factor(x), y = factor(y), fill = z)) + 
  geom_tile() + 
  facet_wrap(~temp, ncol = 2) +  
  scale_fill_viridis(name = "") + 
  scale_y_discrete(name = "Mode", limits = c("14","13","12","10","9","6","5")) +
  scale_x_discrete(name = "Mode", limits = c("3","5","6","9","10","12","13")) 

```


```{r pressure, fig.width=12,fig.height=6, echo=FALSE}
p1
```


# Sources

[1] K. Maes and G. Lombaert. Monitoring railway bridge KW51 before, during, and after retrofitting. v1.0. 2020. doi:10.5281/zenodo.3745914

[2] K. Maes and G. Lombaert. Monitoring railway bridge kw51 before, during, and after retrofitting. Journal of Bridge Engineering, 26(3):04721001, 2021. doi:10.1061/(ASCE)BE.1943-5592.0001668.

[3] L. Neumann, P. Wittenberg, A. Mendler, and J. Gertheiss. Confounder-adjusted Covariances of Sensor Outputs and Applications to Structural Health Monitoring. JOURNAL/PREPRINT, PAGES, YEAR.

[4] J. Yin, Z. Geng, R. Li, and H. Wang. Nonparametric covariance model. Statistica Sinica 20, pages 469–479, 2010.
